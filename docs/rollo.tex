\chapter{ROLLO: Reactor evOLutionary aLgorithm Optimizer}
\label{chap:rollo}
In this chapter, I introduce the \gls{ROLLO} framework, built 
for this dissertation. 
\gls{ROLLO} is a Python package that applies evolutionary algorithm 
techniques to optimize nuclear reactor design. 
Applying evolutionary algorithms to nuclear design problems is not new, as I
previously discussed in Section \ref{sec:opt}, and available evolutionary algorithm 
packages can be customized for reactor design optimization problems. 
However, evolutionary algorithm setup is highly customizable with
an assortment of genetic algorithm designs and operators.
A reactor designer unfamiliar with evolutionary algorithms will have
to go through the cumbersome process of customizing a genetic algorithm 
for their needs and determine which operators and hyperparameters work best for 
their problem. 
Furthermore, computing fitness values with nuclear software is computationally 
expensive, necessitating using supercomputers and setting up parallelization 
for the genetic algorithm.

Therefore, the motivation behind creating \gls{ROLLO} is to limit these inconveniences and 
facilitate using evolutionary algorithms for reactor design optimization.
\gls{ROLLO} provides a general genetic algorithm framework, sets up 
parallelization for the user, and promotes usability with an input file 
that only exposes mandatory parameters.
\gls{ROLLO} also strives to be effective, flexible, open-source, parallel, reproducible, 
and usable. 
I briefly summarize how \gls{ROLLO} achieves these goals:  
\begin{itemize}
    \item Effective: \gls{ROLLO} is well documented, tested, and 
    version-controlled on Github \cite{chee_rollo_2021}.
    \item Flexible: This dissertation uses \gls{ROLLO} to 
    explore arbitrary reactor geometries and heterogeneous fuel distributions. 
    However, future users might want to utilize \gls{ROLLO} 
    to explore other arbitrary design parameters. Thus, I designed the \gls{ROLLO}
    framework accordingly. The user can vary any imaginable parameter 
    because \gls{ROLLO} uses a templating method to edit the input file of the 
    coupled software.
    \item Open-source: \gls{ROLLO} utilizes a well-documented, open-source 
    evolutionary algorithm Python package to drive the optimization process.
    \item Parallel: Users have the option to run \gls{ROLLO} in parallel.
    \item Reproducible: Data from every \gls{ROLLO} run saves into a unique, pickled 
    file (pickle is a Python module that serializes Python objects).
\end{itemize}

\gls{ROLLO} essentially couples an evolutionary algorithm driver with nuclear 
software, such as neutron transport and thermal-hydraulics codes. 
\gls{ROLLO} is nuclear code-agnostic and does not have dependencies on any 
nuclear software. 
Figure \ref{fig:genetic_alg} from Chapter \ref{chap:lit-review} outlines a  
general evolutionary algorithm iterative problem solving process. 
I modified Figure \ref{fig:genetic_alg} to produce Figure 
\ref{fig:genetic_alg_nuclear}, which depicts how the nuclear transport and 
thermal-hydraulics software fit within \gls{ROLLO}'s evolutionary algorithm 
optimization process. 
% need to update with new algorithm style
\begin{figure}[]
    \centering
    \begin{tikzpicture}[node distance=1.7cm]
            \tikzstyle{every node}=[font=\small]
            \node (1) [lbblock] {\textbf{Create initial population}};
            \node (2) [loblock, below of=1] {\textbf{Evaluate initial population}};
            \node (3) [lbblock, below of=2, yshift = -1.3cm] {\textbf{Create offspring population:} \\ 
            \begin{enumerate} \item Apply \textbf{crossover} operator to previous population
                              \item Apply \textbf{mutation} operator to previous population
                              \end{enumerate}};
            \node (4) [loblock, below of=3, yshift=-1.3cm] {\textbf{Evaluate offspring population}};
            \node (7) [lbblock, below of=4, yshift = -1.3cm] {\textbf{Create new population:} \\
            \begin{enumerate} \item Apply \textbf{selection} operator to offspring + previous population
                              \item Apply constraints to new population
                              \end{enumerate}};
            \node (5) [lbblock, below of=7, yshift=-1.3cm] {\textbf{Is termination \\ criteria satisfied?}};
            \node (6) [lbblock, below of=5] {\textbf{Best solution is returned!}};
            \draw [arrow] (1) -- (2);
            \draw [arrow] (2) -- (3);
            \draw [arrow] (3) -- (4);
            \draw [arrow] (4) -- (7);
            \draw [arrow] (7) -- (5);
            \draw [arrow] (5) -- node[anchor=east] {yes} (6);
            \draw [arrow] (5) -- ([shift={(0.5cm,0cm)}]5.east)-- node[anchor=west] {no} ([shift={(0.5cm,0cm)}]3.east)--(3);
            \matrix [draw,above right,yshift=10.7cm, xshift=0cm] at (current bounding box.south east) {
            \node [bbblock,label=right:\textbf{EA: Evolutionary Algorithm}] {}; \\
            \node [boblock,label=right:\textbf{NS: Nuclear Software}] {}; \\
            };
    \end{tikzpicture}
    \caption{Process of finding optimal solutions for a problem with a 
    genetic algorithm. Nuclear software evaluates each new population.}
    \label{fig:genetic_alg_nuclear}
\end{figure}
\gls{ROLLO} initially reads and validates the JSON input 
file, initializes the \gls{DEAP} \cite{fortin_deap_2012} genetic algorithm 
hyperparameters and operators, and finally runs the genetic algorithm following 
the flow chart in Figure \ref{fig:genetic_alg_nuclear}, in which the nuclear 
software evaluates each individual's fitness. 

% update this 
In the subsequent sections, I describe the evolutionary algorithm software (DEAP)
that drives \gls{ROLLO}, the nuclear software coupled to \gls{ROLLO}, and details about 
the \gls{ROLLO} framework, such as the input file format and software architecture. 

\section{Evolutionary Algorithm Driver}
Evolutionary algorithm computation uses sophisticated, diverse techniques 
and mechanisms, resulting in even the most well-designed, software frameworks 
being complicated under the hood. 
Utilizing an existing evolutionary algorithm framework presents implementation 
challenges as the user must edit the framework's source code to customize for their 
application and hyperparameters \cite{fortin_deap_2012}. 
Therefore, a computation framework that gives the user the capability to build 
custom evolutionary algorithms is ideal for this project.

Many evolutionary algorithm computation packages exist: 
\gls{DEAP} \cite{fortin_deap_2012}, inspyred \cite{garrett_inspyred_2014}, 
Pyevolve \cite{perone_pyevolve_2009}, and OpenBEAGLE \cite{gagne_open_2002}.
\gls{DEAP} is the newest package and places a high value on code 
compactness and clarity \cite{fortin_deap_2012}. 
\gls{DEAP} is the only framework that allows the user to prototype evolutionary 
algorithms rapidly and define custom algorithms without digging deep into 
the source code to modify hyperparameters and their application methods.
Accordingly, I chose \gls{DEAP} to drive the \gls{ROLLO} framework's 
evolutionary algorithm component. 
\gls{DEAP} provides building blocks for each optimizer function and allows the 
user to customize a specialized algorithm to fit their project \cite{fortin_deap_2012}.

\subsection{Distributed Evolutionary Algorithms in Python}
\label{sec:deap-works}
\gls{DEAP} is composed of two simples structures: a \textit{creator} and a 
\textit{toolbox}.  
The \textit{creator} module allows the run-time creation of classes via 
inheritance and composition, enabling individual and population creation from 
from any data structure: lists, sets, dictionaries, trees, etc \cite{fortin_deap_2012}. 
The \textit{toolbox} is a container that the user manually populates.
In the \textit{toolbox}, the user defines the selection, crossover, and 
mutation operator types and hyperparameters. 
For example, the user registers a crossover operator under the `mate'
alias, and a selection operator under the `select' alias. 
Then, the evolutionary algorithm uses these aliased operators from the 
\textit{toolbox}. 
If the user wants to change the crossover operator, they would update the 
`mate' alias in the \textit{toolbox}, while keeping the evolutionary algorithm 
unchanged \cite{fortin_deap_2012}. 

Figure \ref{fig:deap-code} illustrates \gls{DEAP}'s usage of the \textit{creator} and
\textit{toolbox} modules. 
\begin{figure}[]
    \begin{minted}[
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        fontsize=\footnotesize,
        linenos
        ]{python}
        
        from deap import creator, base, tools, algorithms
        creator.create("Objective", base.Fitness, weights=(-1.0,)) # minimum
        creator.create("Individual", list, fitness=creator.Objective)

        toolbox = base.Toolbox()
        toolbox.register("variable_1", random.uniform, 0.0, 10.0)
        toolbox.register("variable_2", random.uniform, -1.0, 0.0)
        def individual_creator():
            return creator.Individual([toolbox.variable_1(), toolbox.variable_2()])
        toolbox.register("individual", individual_creator())
        toolbox.register("population", tools.initRepeat, list, toolbox.individual)
        def evaluator_fn(individual):
            return tuple([sum(individual)])
        toolbox.register("evaluate", evaluator_fn)
        toolbox.register("select", tools.selBest, k=5)
        toolbox.register("mutate", tools.mutPolynomialBounded, eta=0.5, low=[0, -1], up=[-1, 0])
        toolbox.register("mate", tools.cxOnePoint)
    \end{minted}
    \caption{DEAP sample code demonstrating the usage of the \textit{creator} and
    \textit{toolbox} modules to initialize the genetic algorithm. In \gls{ROLLO}, \gls{DEAP}'s 
    \textit{creator} and \textit{toolbox} modules are initialized in the source 
    code based on the genetic algorithm parameters defined by the user in the 
    \gls{ROLLO} input file. }
    \label{fig:deap-code}
\end{figure}
Line 2 creates a single-objective fitness class, \texttt{Objective}. 
The first argument defines the name of the derived class, the second argument 
specifies the inherited base class, \texttt{base.fitness}, and the third 
argument indicates the objective fitness ($-1.0$ indicates a minimum objective, 
$+1.0$ indicates a maximum objective). 
Line 3 derives an \texttt{Individual} class from the standard Python list type,
and defines its fitness attribute to be the newly created \texttt{Objective} object. 
Lines 5-9 initialize the \gls{DEAP} toolbox, register 
\texttt{variable\_1} and \texttt{variable\_2} with their upper and lower bounds, 
and defines the \texttt{individual\_creator} function to return an 
\texttt{Individual} initialized with \texttt{variable\_1}, and \texttt{variable\_2}. 
Lines 10-11 and 14-17 are aliases for initializing individuals and population, 
specifying variation operators (\texttt{select}, \texttt{mutate}, \texttt{mate}), 
and evaluating individual fitness (\texttt{evaluate}) \cite{fortin_deap_2012}. 
Lines 12-13 define the evaluation function that returns the fitness values. 

\gls{ROLLO} initializes \gls{DEAP}'s \textit{creator} and \textit{toolbox} modules 
based on the genetic algorithm parameters defined by the user in the \gls{ROLLO} 
input file. 
The evaluation function runs the nuclear software and returns user-defined 
fitness values. 

\subsection{ROLLO Evolutionary Algorithm Implementation}
\gls{DEAP} creators provided variations of a classical genetic algorithm 
exposing different explicitness levels \cite{fortin_deap_2012}. 
The high-level examples use the built-in \gls{DEAP} genetic algorithms, 
whereas the low-level example completely unpacks the genetic algorithm to expose 
a generational loop. 

I included a completely unpacked genetic algorithm in ROLLO's 
\textbf{\textit{Algorithm}} class, depicted in Figure \ref{fig:genetic_alg_nuclear}. 
The algorithm begins by initializing the starting population and evaluating 
each individual's fitness value. 
Then, it enters a generational loop. 
During each iteration, the mating and mutation operators are applied to the population
to create an offspring population, and all offspring individuals are evaluated. 
The selection operator is then applied to both the previous and offspring populations 
to select the best individuals to create the new population. 
Finally, the constraints are applied, and the results are saved.

Applying the selection operator to the combined previous and offspring 
populations expands the population ensuring the effectiveness of 
elitism selection operators, such as NSGA-II, which work well 
for multi-objective optimization. 

\section{ROLLO Input File}
\gls{ROLLO}'s input file is in JSON format. 
There are four sections that the user must define: \\ \texttt{control\_variables}, 
\texttt{evaluators}, \texttt{constraints}, and \texttt{algorithm}. 
Figure \ref{fig:rollo-input} shows an example \gls{ROLLO} input file. 
In this simulation, \gls{ROLLO} uses a genetic algorithm with the user-defined 
hyperparameters to minimize the \texttt{output1} parameter which is 
calculated using the OpenMC evaluator that accepts input parameters: 
\texttt{variable1} and \texttt{variable2}. 
\begin{figure}[]
    \begin{minted}[
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        fontsize=\footnotesize,
        linenos
        ]{json}
        {
            "control_variables": {
                "variable1": {"min": 0.0, "max": 10.0}, 
                "variable2": {"min": -1.0, "max": 0.0}
            }, 
            "evaluators": {
                "openmc": {
                    "order": 0,
                    "inputs": ["variable1", "variable2"],
                    "input_script": ["python", "openmc_inp.py"],
                    "execute": [["openmc"],],
                    "outputs": ["output1", "output2"]
                    "output_script": ["python", "openmc_output.py"], 
                }
            }, 
            "constraints": {
                "output1": {"operator": [">=", "<"], "constrained_val": [1.0, 1.5]}
            }, 
            "algorithm": {
                "objective": ["min"], 
                "weight": [1.0],
                "optimized_variable": ["output1"], 
                "pop_size": 100, 
                "generations": 10, 
                "parallel": "job_control",
                "keep_files": "all",
                "mutation_probability": 0.23,
                "mating_probability": 0.46,
                "selection_operator": {"operator": "selTournament", "tournsize":5},
                "mutation_operator": {
                    "operator": "mutPolynomialBounded",
                    "indpb": 0.23,
                    "eta": 0.23
                },
                "mating_operator": {"operator": "cxBlend", "alpha": 0.46}
            }
        }
    \end{minted}
    \caption{\acrfull{ROLLO} sample JSON input file.}
    \label{fig:rollo-input}
\end{figure}

Next, I will describe how to define each section of a \gls{ROLLO} input file. 
The \gls{ROLLO} documentation \cite{chee_documentation_2021} provides further 
descriptions for setting up a \gls{ROLLO} input file.

\subsection{Control Variables}
Control variables are parameters the genetic algorithm will vary. 
For each control variable, the user must specify its minimum and maximum values.
For example, Lines 2 to 5 in Figure \ref{fig:rollo-input} demonstrate that the 
control variables, \texttt{variable1} and \texttt{variable2}, 
will be varied from 0 to 10 and -1 to 0, respectively. 
For example, in traditional reactor design, a control variable might be fuel 
enrichment. 

\subsection{Evaluators}
Evaluators are the nuclear software \gls{ROLLO} utilizes to calculate objective functions. 
\gls{ROLLO} is nuclear code-agnostic and does not have dependencies on any 
nuclear software.
Thus, it is up to the user to ensure that the nuclear software and their corresponding 
executables are properly installed. 
In a single \gls{ROLLO} input file, users may define any number of evaluators. 
For each evaluator, mandatory parameters are \texttt{order}, \texttt{input\_script}, 
\texttt{inputs}, and \texttt{outputs}, and the optional parameters are
\texttt{execute} and \texttt{output\_script}. 
Table \ref{tab:evaluator-inputs} describes the mandatory and optional parameters 
accepted by each evaluator in ROLLO's \texttt{evaluators} input file section.  
\begin{table}[]
    \centering
    \onehalfspacing
    \caption{\acrfull{ROLLO} \texttt{evaluator}: Input Parameter Descriptions.}
	\label{tab:evaluator-inputs}
    \footnotesize
    \begin{tabular}{l|lp{2.5cm}p{7cm}}
    \hline
    & \textbf{Parameter} & \textbf{Type} & \textbf{Description} \\
    \hline
    \multirow{9}{2cm}{Mandatory Parameters} & \texttt{order} & int 
    & evaluator's operational order compared to other evaluators (indexed by 0) \\
    \cline{2-4}
    & \texttt{inputs} & list of strings & control variables placed in input script template \\
    \cline{2-4}
    & \texttt{input\_script} & list of strings (2-element) & first element: executable to run input script, 
    second element: input script template's name \\
    \cline{2-4}
    & \texttt{outputs} & list of strings & output variables that the evaluator will return to the genetic algorithm \\
    \hline
    \multirow{4}{2cm}{Optional Parameters} & \texttt{execute} & list of 2-element lists &
    enables the user to run other executables or files beyond the input and output scripts. first element: executable to run file, 
    second element: file to run \\
    \cline{2-4}
    & \texttt{output\_script} & list of strings (2-element) & first element: executable to run output script, 
    second element: output script's name \\
    \hline 
    \end{tabular}
    \end{table}

\gls{ROLLO} utilizes jinja2 templating \cite{ronacher_welcome_2018} to insert 
the control variable values into the \texttt{input\_script}.
Users must include each evaluator's input file template in the same directory as the \gls{ROLLO} input 
file. 
Users must also ensure the template variables correspond to the \texttt{inputs} defined in the 
corresponding evaluator's section in the ROLLO input file. 
Lines 6 to 13 in the \gls{ROLLO} input file (Figure \ref{fig:rollo-input}) demonstrate 
that \texttt{variable1} and \texttt{variable2} are \texttt{inputs} into the 
\texttt{openmc\_inp.py} \texttt{input\_script}. 
Figure \ref{fig:openmcinp.py} shows the template and templated openmc script; 
once the \texttt{openmc\_inp.py} \texttt{input\_script} is templated, 
\texttt{\{\{variable1\}\}} and \texttt{\{\{variable2\}\}}  on Lines 3 and 4 will be 
replaced with values selected by the \gls{ROLLO} genetic algorithm. 
\begin{figure}[]
    \begin{minipage}{0.4\textwidth}
        \centering
    \begin{minted}[
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        fontsize=\footnotesize,
        linenos
        ]{python}
        import openmc 
        # templating 
        variable1 = {{variable1}}
        variable2 = {{variable2}}
        # run openmc 
        ... 
    \end{minted}
    \end{minipage}
    \hspace{2cm}
    \begin{minipage}{0.4\textwidth}
        \centering
        \begin{minted}[
            frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            fontsize=\footnotesize,
            linenos
            ]{python}
            import openmc 
            # templating 
            variable1 = 3.212
            variable2 = -0.765
            # run openmc 
            ... 
        \end{minted}
        \end{minipage}
    \caption{\texttt{openmc\_inp.py} input script template (left). 
             Templated \texttt{openmc\_inp.py} with variable1 and variable2 
             values defined (right).}
    \label{fig:openmcinp.py}
\end{figure}

\gls{ROLLO} uses two methods to return an output variable to the genetic algorithm. 
First, if the output parameter is also an input parameter, \gls{ROLLO} will automatically 
return the input parameter's value. 
Second, the user may include an \texttt{output\_script} that returns the desired 
output parameter. 
The \texttt{output\_script} must include a line that prints a dictionary containing 
the output parameters' names and their corresponding value as key-value pairs. 

\subsection{Constraints}
In the constraints section, the user can define constraints on any output parameter. 
Any individual that does not meet the defined constraints is removed from the 
population, encouraging the proliferation of individuals that meet the 
constraints. 
For each constrained output parameter, the user lists the \texttt{operator}s 
and \texttt{constrained\_val}s as in Line 17 of the \gls{ROLLO} input file 
(Figure \ref{fig:rollo-input}). 
Thus, for this \gls{ROLLO} simulation, \texttt{output\_1} is constrained to be 
$>= 1.0$ and $< 1.5$. 
For example, in reactor design, a constraint might be maximum temperature in the 
core.

\subsection{Algorithm}
In the algorithm section, users define the simulation's general settings and 
genetic algorithm's hyperparameters. 
The mandatory input parameters include \texttt{objective}, \texttt{optimized\_variable}, 
\texttt{pop\_size}, and \texttt{generations}.
The optional input parameters include \texttt{parallel}, 
\texttt{mutation\_probability}, \\ \texttt{mating\_probability}, 
\texttt{selection\_operator}, \texttt{mutation\_operator}, 
and \texttt{mating\_operator}. 
Lines 17 to 31 in the example \gls{ROLLO} input file (Figure \ref{fig:rollo-input}) 
demonstrate \texttt{algorithm} specifications. 
Table \ref{tab:algorithm-inputs} describes the input parameters accepted by
ROLLO's \texttt{algorithm} input file section.  
\begin{table}[]
    \centering
    \onehalfspacing
    \caption{\acrfull{ROLLO} \texttt{algorithm}: Input Parameter Descriptions.}
	\label{tab:algorithm-inputs}
    \footnotesize
    \begin{tabular}{l|lp{1.7cm}p{4cm}p{2cm}}
    \hline
    & \textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} \\
    \hline
    \multirow{9}{1.8cm}{Mandatory Parameters} 
    & \texttt{objective} & list of strings & & -\\
    \cline{2-5}
    & \texttt{optimized\_variable} & list of strings & & -\\
    \cline{2-5}
    & \texttt{pop\_size} & int & population size & -\\
    \cline{2-5}
    & \texttt{generations} & int & number of generations & -\\
    \hline
    \multirow{9}{1.8cm}{Optional Parameters} 
    & \texttt{weight} & list of floats & & $[1.0]*len(objective)$\\
    \cline{2-5}
    & \texttt{parallel} & string & options include: \textit{none}, \textit{multiprocessing}, \textit{job\_control} & -\\
    \cline{2-5}
    & \texttt{keep\_files} & string & options include: \textit{none}, \textit{only\_final}, \textit{all} & \textit{all} \\
    \cline{2-5}
    & \texttt{mutation\_probability} & float & mutation probability & 0.23 \\
    \cline{2-5}
    & \texttt{mating\_probability} & float & mating probability & 0.47 \\
    \cline{2-5}
    & \texttt{selection\_operator} & dict & see Table \ref{tab:deap_operators} & \\
    \cline{2-5}
    & \texttt{mutation\_operator} & dict & see Table \ref{tab:deap_operators} & \\
    \cline{2-5}
    & \texttt{mating\_operator} & dict & see Table \ref{tab:deap_operators} & \\
    \hline 
    \end{tabular}
    \end{table}

As mentioned previously in Section \ref{sec:genetic_alg}, it is important to 
select genetic algorithm hyperparameters that balance the extent of exploration 
and exploitation.
For each operator, the user can choose from a list of operators and define each
of their required hyperparameters. 
Table \ref{tab:deap_operators} shows the available operators and their respective 
hyperparameters. 
\begin{table}[]
    \centering
    \onehalfspacing
    \caption{Selection, mutation, and mating operators available in 
    \acrfull{ROLLO} and their corresponding hyperparameters. }
	\label{tab:deap_operators}
    \footnotesize
    \begin{tabular}{l|p{0.23\textwidth}|p{0.55\textwidth}}
    \hline
    \textbf{Operator} & \textbf{Available Options} & \textbf{Hyperparameters} \\ \hline
    \multirow{4}{1cm}{Selection} & \multirow{2}{2cm}{\texttt{selTournament}} & \texttt{tournsize}: no. of individuals in each tournament\\ 
    & & \texttt{inds}: no. of individuals to select \\ \cline{2-3}
    & \texttt{selNSGA2} & \texttt{inds}: no. of individuals to select\\ \cline{2-3}
    & \texttt{selBest} & \texttt{inds}: no. of individuals to select\\ \hline
    \multirow{2}{1cm}{Mutation} & \multirow{2}{2cm}{\texttt{mutPolynomialBounded}} & \texttt{eta}: crowding degree of the mutation\\  
    && \texttt{indpb}: independent probability for each attribute to be mutated\\ \hline
    \multirow{3}{1cm}{Mating} & \texttt{cxOnePoint} & -\\ \cline{2-3}
    & \texttt{cxUniform} & \texttt{indpb}: independent probability for each attribute to be exchanged\\ \cline{2-3}
    & \texttt{cxBlend} & \texttt{alpha}: Extent of the interval in which the new values can be drawn for each attribute on both side of the parents’ attributes\\ \hline
    \end{tabular}
    \end{table}

\section{ROLLO Software Architecture}
In this section, I will describe the \gls{ROLLO} v1.0 software architecture and 
how all the parts come together to optimize reactor design.
Table \ref{tab:rollo-architecture} outlines the classes in the \gls{ROLLO} software 
and describes each class's purpose.
\begin{table}[]
    \centering
    \onehalfspacing
    \caption{Classes that make up the \gls{ROLLO} architecture. }
	\label{tab:rollo-architecture}
    \footnotesize
    \begin{tabular}{l|p{0.73\textwidth}}
    \hline
    \textbf{Class} & \textbf{Description} \\ \hline
    \textbf{\textit{InputValidation}} & The \textbf{\textit{InputValidation}} class contains methods 
    to read and validate the JSON \gls{ROLLO} input file to 
    ensure the user defined all key parameters. If they did not, \gls{ROLLO} 
    raises an exception to tell the user which parameters are missing. \\
    \hline
    \textbf{\textit{Evaluation}} & \gls{DEAP}'s fitness evaluator (as mentioned in Section 
    \ref{sec:deap-works}) requires an evaluation function to evaluate each 
    individual's fitness values. 
    The \textbf{\textit{Evaluation}} class contains a method that creates an evaluation 
    function that runs the nuclear software and returns the required fitness values, 
    defined in the input file. \\
    \hline 
    \textbf{\textit{OpenMCEvaluation}} & The \textbf{\textit{OpenMCEvaluation}} class contains
    built-in methods for evaluating OpenMC output files. Developers can update 
    this file with methods to evaluate frequently used OpenMC outputs. \\
    \hline 
    \textbf{\textit{ToolboxGenerator}} & The \textbf{\textit{ToolboxGenerator}} class initializes
    \gls{DEAP}'s \textit{toolbox} and \textit{creator} modules with genetic algorithm 
    hyperparameters defined in the input file.\\
    \hline
    \textbf{\textit{Constraints}} & The \textbf{\textit{Constraints}} class 
    contains methods to initialize constraints defined in the input file 
    and applies the constraints by removing individuals that do not meet the 
    constraint.\\
    \hline 
    \textbf{\textit{BackEnd}} & The \textbf{\textit{BackEnd}} class contains methods to save 
    genetic algorithm population results into a pickled checkpoint file and to 
    restart a partially completed genetic algorithm from the checkpoint file. \\
    \hline
    \textbf{\textit{Algorithm}} & The \textbf{\textit{Algorithm}} class contains methods to 
    initialize and execute the genetic algorithm. It executes a general genetic 
    algorithm framework that uses the hyperparameters defined in the 
    \textbf{\textit{ToolboxGenerator}}, applies constraints defined in
    \textbf{\textit{Constraints}}, evaluates fitness values using the evaluation 
    function produced by \textbf{\textit{Evaluation}}, and saves all the results 
    with \textbf{\textit{BackEnd}}. \\
    \hline
    \textbf{\textit{Executor}} & The \textbf{\textit{Executor}} class drives the \gls{ROLLO} code
    execution with the following steps: \\
    & 1) User input file validation with \textbf{\textit{InputValidation}} \\
    & 2) Evaluation function generation with \textbf{\textit{Evaluation}} \\
    & 3) \gls{DEAP} toolbox initialization with \textbf{\textit{ToolboxGenerator}} \\ 
    & 4) Constraint initialization with \textbf{\textit{Constraints}} \\ 
    & 5) Genetic algorithm execution with \textbf{\textit{Algorithm}} \\
    \hline
    \end{tabular}
    \end{table}

\section{ROLLO Verification}

\section{ROLLO Stopping Criteria}