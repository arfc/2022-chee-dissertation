\chapter{ROLLO: Reactor evOLutionary aLgorithm Optimizer}
\label{chap:rollo}
In this chapter, I introduce the \gls{ROLLO} framework, built 
for this dissertation. 
\gls{ROLLO} is a Python package that applies evolutionary algorithm 
techniques to optimize nuclear reactor design. 
Applying evolutionary algorithms to nuclear design problems is not new, as I
previously discussed in Section \ref{sec:opt}, and available evolutionary algorithm 
packages can be customized for reactor design optimization problems. 
However, evolutionary algorithm setup is highly customizable with
an assortment of genetic algorithm designs and operators.
A reactor designer unfamiliar with evolutionary algorithms will have
to go through the cumbersome process of customizing a genetic algorithm 
for their needs and determine which operators and hyperparameters work best for 
their problem. 
Furthermore, computing fitness values with nuclear software is computationally 
expensive, necessitating using supercomputers and setting up parallelization 
for the genetic algorithm.

Therefore, the motivation behind creating \gls{ROLLO} is to limit these inconveniences and 
facilitate using evolutionary algorithms for reactor design optimization.
\gls{ROLLO} provides a general genetic algorithm framework, sets up 
parallelization for the user, and promotes usability with an input file 
that only exposes mandatory parameters.
\gls{ROLLO} also strives to be effective, flexible, open-source, parallel, reproducible, 
and usable. 
I briefly summarize how \gls{ROLLO} achieves these goals:  
\begin{itemize}
    \item Effective: \gls{ROLLO} is well documented, tested, and 
    version-controlled on Github \cite{chee_rollo_2021}.
    \item Flexible: This dissertation uses \gls{ROLLO} to 
    explore arbitrary reactor geometries and heterogeneous fuel distributions. 
    However, future users might want to utilize \gls{ROLLO} 
    to explore other arbitrary design parameters. Thus, I designed the \gls{ROLLO}
    framework accordingly. The user can vary any imaginable parameter 
    because \gls{ROLLO} uses a templating method to edit the input file of the 
    coupled software.
    \item Open-source: \gls{ROLLO} utilizes a well-documented, open-source 
    evolutionary algorithm Python package to drive the optimization process.
    \item Parallel: Users have the option to run \gls{ROLLO} in parallel
    \item Reproducible: Data from every \gls{ROLLO} run saves into a unique, pickled 
    file (pickle is a Python module that serializes Python objects), and all 
    results from this work are available on Github. 
\end{itemize}

\gls{ROLLO} essentially couples an evolutionary algorithm driver with nuclear 
software, such as neutron transport and thermal-hydraulics codes. 
\gls{ROLLO} is nuclear code-agnostic and does not have dependencies on any 
nuclear software. 
Figure \ref{fig:genetic_alg} from Chapter \ref{chap:lit-review} outlines the 
evolutionary algorithm iterative problem solving process. 
I modified Figure \ref{fig:genetic_alg} to produce Figure 
\ref{fig:genetic_alg_nuclear}, which depicts how the nuclear transport and 
thermal-hydraulics software fit within \gls{ROLLO}'s evolutionary algorithm 
optimization process. 
% need to update with new algorithm style
\begin{figure}[]
    \centering
    \begin{tikzpicture}[node distance=1.7cm]
            \tikzstyle{every node}=[font=\small]
            \node (1) [lbblock] {\textbf{Create initial population}};
            \node (2) [loblock, below of=1] {\textbf{Evaluate initial population}};
            \node (3) [lbblock, below of=2, yshift = -1.3cm] {\textbf{Create new population:} \\ 
            \begin{enumerate} \item \textbf{Select} individuals for mating 
                              \item Create offspring by \textbf{crossover} 
                              \item \textbf{Mutate} selected individuals 
                              \item Keep selected individuals from previous generation
                             \end{enumerate}};
            \node (4) [loblock, below of=3, yshift=-1.3cm] {\textbf{Evaluate new population}};
            \node (5) [lbblock, below of=4] {\textbf{Is termination \\ criteria satisfied?}};
            \node (6) [lbblock, below of=5] {\textbf{Best solution is returned!}};
            \draw [arrow] (1) -- (2);
            \draw [arrow] (2) -- (3);
            \draw [arrow] (3) -- (4);
            \draw [arrow] (4) -- (5);
            \draw [arrow] (5) -- node[anchor=east] {yes} (6);
            \draw [arrow] (5) -- ([shift={(0.5cm,0cm)}]5.east)-- node[anchor=west] {no} ([shift={(0.5cm,0cm)}]3.east)--(3);
            \matrix [draw,above right,yshift=10.7cm, xshift=0cm] at (current bounding box.south east) {
            \node [bbblock,label=right:\textbf{EA: Evolutionary Algorithm}] {}; \\
            \node [boblock,label=right:\textbf{NS: Nuclear Software}] {}; \\
            };
    \end{tikzpicture}
    \caption{Process of finding optimal solutions for a problem with a 
    genetic algorithm. Nuclear software evaluates each new population.}
    \label{fig:genetic_alg_nuclear}
\end{figure}
\gls{ROLLO} initially reads and validates the JSON input 
file, initializes the \gls{DEAP} \cite{fortin_deap_2012} genetic algorithm 
hyperparameters and operators, and finally runs the genetic algorithm following 
the flow chart in Figure \ref{fig:genetic_alg_nuclear}, in which the nuclear 
software evaluates each individual's fitness. 

% update this 
In the subsequent sections, I describe the evolutionary algorithm software (DEAP)
that drives \gls{ROLLO}, the nuclear software coupled to \gls{ROLLO}, and details about 
the \gls{ROLLO} framework, such as the input file format and software architecture. 

\subsection{\acrlong{DEAP}}

\subsection{ROLLO Input File}

\subsection{ROLLO Software Architecture}

\subsection{ROLLO Verification}

\subsection{ROLLO Stopping Criteria}